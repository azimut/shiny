diff --git a/examples/fluid.lisp b/examples/fluid.lisp
index e4d46e9..cd23745 100644
--- a/examples/fluid.lisp
+++ b/examples/fluid.lisp
@@ -9,437 +9,8 @@
   (loop :for c :from 0 :upto 25 :do
      (mapcar (lambda (x) (fluidsynth:noteoff s c x)) (range 120))))
 
-(defvar *fluid-settings* (fluidsynth:new-settings
-                          `(("synth.polyphony" 128)
-                            ("synth.midi-channels" 32)
-                            ("synth.sample-rate" ,*sample-rate*)
-                            ("audio.sample-format" "float"))))
-
-
-(defvar *synth* (fluidsynth:new *fluid-settings*))
-
-;; (defparameter *env1* (make-envelope '(0 1 1 0) '(0 .9 .1)))
-
-(dsp! fluid-test ((synth fluidsynth:synth))
-  (with ((len (block-size))
-         (left (make-f32-array len))
-         (right (make-f32-array len)))
-    (fluidsynth:write-float synth len left 0 1 right 0 1)
-    (foreach-frame
-      (out (f32-ref left current-frame)
-           (f32-ref right current-frame)))))
-
-;(fluidsynth:sfload *synth* "/home/sendai/Downloads/fluid-soundfont-3.1/FluidR3_GM.sf2" 1)
-;(fluidsynth:sfload *synth* "/usr/share/sounds/sf2/FluidR3_GM.sf2" 1)
-;(fluidsynth:sfload *synth* "/home/sendai/Downloads/samples/GeneralUser GS 1.471/GeneralUser GS v1.471.sf2" 1)
-;(fluidsynth:sfload *synth* "/home/sendai/Downloads/Sonatina_Symphonic_Orchestra.sf2" 1)
-(fluidsynth:sfload *synth* "/home/sendai/Nice-Keys-Ultimate-V2.3.sf2" 1)
-;(fluidsynth:sfload *synth* "/home/sendai/Downloads/samples/grand-piano-YDP-20160804/grand-piano-YDP-20160804.sf2" 1)
-;(fluidsynth:sfload *synth* "/home/sendai/Downloads/samples/KawaiUprightPiano-20180102/KawaiUprightPiano-20180102.sf2" 1)
-
-#|
-(fluidsynth:get-active-voice-count *synth*)
-(fluidsynth:stop *synth* 1)
-(incudine:free 0)
-(fluidsynth:delete *synth*)
-|#
-
-(fluidsynth:set-reverb *synth* 0.7d0 0.9d0 0.5d0 0.9d0)
-(set-rt-block-size 64)
-
-(setf (fluidsynth:setting *fluid-settings* "synth.gain") .7)
-;(setf (fluidsynth:setting *fluid-settings* "synth.polyphony") 128)
-;(setf (fluidsynth:setting *fluid-settings* "synth.midi-channels") 24)
-
-(rt-stop)
-(rt-start)
-(fluid-test *synth*)
-;;(fluidsynth:program-change *synth* 11 2)
-(fluidsynth:program-change *synth* 23 0)
-(fluidsynth:program-change *synth* 22 0)
-(fluidsynth:program-change *synth* 21 1)
-(fluidsynth:program-change *synth* 20 0)
-(fluidsynth:program-change *synth* 19 0)
-(fluidsynth:program-change *synth* 18 0)
-(fluidsynth:program-change *synth* 17 0)
-(fluidsynth:program-change *synth* 15 0)
-(fluidsynth:program-change *synth* 14 0)
-(fluidsynth:program-change *synth* 13 0)
-(fluidsynth:program-change *synth* 12 0)
-(fluidsynth:program-change *synth* 10 0)
-(fluidsynth:program-change *synth* 9 3)
-(fluidsynth:program-change *synth* 9 3)
-(fluidsynth:program-change *synth* 9 3)
-(fluidsynth:noteon *synth* 0 60 100)
-
-#|
-(incudine:free 1)
-(flush-pending)
-(define play-midi-note
-  (lambda (time device pitch velocity duration channel)
-    (callback time 'midi_send device *midi-note-on* channel pitch velocity)
-    (callback (+ time duration) 'midi_send device *midi-note-off* channel pitch velocity)))
-|#
-
-(defun play-midi-note (time pitch velocity dur c)
-     (at time #'fluidsynth:noteon *synth* c pitch velocity)
-     (at (+ time #[dur s]) #'fluidsynth:noteoff *synth* c pitch)
-  )
-
-(play-midi-note (now) 60 90 2 15)
-(play-midi-note (now) 36 60 1 1)
-(play-midi-note (now) 36 60 10 (random 6))
-
-;; ----------------------
-;; DANCING PHALANGES
-(setf (bpm *tempo*) 60)
-(defvar *root* nil)
-(setf *root* 0)
-(defvar *degree* nil)
-(setf *degree* 'i)
-(defvar *scale* nil)
-(setf *scale* (scale 0 'phrygian))
-
-(defun melody (time ms rs)
-  (if (not ms)
-      'done
-      (let ((p (car ms))
-            (d (car rs)))
-        ;; (play-midi-note time
-        ;;                 (quant (+ 48 *root* p) *scale*)
-        ;;                 (round (cosr 60 40 1/2)) 
-        ;;                 (* d (cosr 4. .2 1/2))
-        ;;                 1)
-        (play-midi-note time
-                        (quant (+ 55 *root* p) *scale*)
-                        (round (cosr 60 40 1/2))
-                        (* d (cosr 4. .2 1/2))
-                        2)
-        (aat (+ time #[d b]) #'melody it (cdr ms) (cdr rs))
-        )))
-
-(defun right (degree)
-  (setf *degree* degree)
-  (setf *root* (car (diatonic 0 '- degree)))
-  (at (+ (now) #[4 b]) #'right (random-list (cdr (assoc degree '((i n6 iii vii)
-                                                                 (n6 v7)
-                                                                 (iii v7)
-                                                                 (vii vi)
-                                                                 (vi vii v7 v7)
-                                                                 (v7 i))))))
-  )
-
-(right 'i)
-
-(defun left (time dur)
-  (if (> (random 1.0) .85) (melody time '(0 1 0 -1) '(1/3 2/3 2/3 1)))
-;  (play-midi-note time
-;                  (+ 48 *root*)
-;                  (round (cosr 80 30 1))
-;                  (* dur (cosr 2.2 .3 1/7))
-;                  2)
-  (play-midi-note time
-                  36
-                  (round (cosr 40 30 1))
-                  (* dur (cosr .6 .3 1/7))
-                  0)
-  (aat (tempo-sync #[dur b]) #'left it (random-list '(1 2/3))))
-
-(left (now) 2/3)
-(flush-pending)
-(incudine:free 0)
-
-;; -----------------------------------
-;; Overtone example
-;; "Piano phase" - https://en.wikipedia.org/wiki/Piano_Phase
-;; ----------------------------------
-
-(defvar *piece* nil)
-(setf *piece* '(:E4 :F#4 :B4 :C#5 :D5 :F#4 :E4 :C#5 :B4 :F#4 :D5 :C#5))
-
-(repeat 1000 *piece*)
-
-(setf (bpm *tempo*) 35)
-
-(defun player (time speed notes c)
-  (let ((note      (first notes))
-        (notes  (cdr notes))) 
-    (when note
-      (play-midi-note time
-                      (note-name-to-midi-number (symbol-name note))
-                      (round (cosr 60 10 1/2))
-                      1
-                      c)
-      (aat (+ time speed) #'player it speed notes c))))
-
-#|
-(player (now) #[.335 b] *piece* 0)
-(flush-pending)
-|#
-
-(let ((time (now)))
-  (player time #[.338 b] *piece* 0)
-  (player time #[.335 b] *piece* 1))
-
-;; --------------------------------------------------------------------
-;; Another late christmas
-;; --------------------------------------------------------------------
-(setf (bpm *tempo*) 30)
-(defvar *root* nil)
-(setf *root* 72)
-
-(defun loop1 (time dur)
-  (play-midi-note time
-                  (if (= (mod (get-internal-real-time) 12) 0)
-                      67
-                      (random-list '(60 60 60 58)))
-                  50
-                  dur
-                  0)
-  (aat (tempo-sync #[(* .5 dur) b]) #'loop1 it dur))
-
-(defun s ()
-;;  '(0)
-  '(0 2 3 5)
-)
-
-(defun loop2 (time dlist slist)
-  (if (car slist)
-      (play-midi-note time
-                      (relative *root* (car slist) (s))
-                      (rrandom 60 80)
-                      (car dlist)
-                      1))
-  (aat (tempo-sync #[(car dlist) b]) #'loop2 it
-       (alexandria:rotate dlist -1)
-       (alexandria:rotate slist -1)))
-
-#|
-(loop1 (now) 1)
-(loop2 (now) '(1 1/2 1/2 1/2 1/2) '(2 1 2 0 nil))
-(setf *root* 72)
-(setf *root* 63)
-(flush-pending)
-|#
-
-;; Ah!...tempo-sync...I mean beat...without it I cannot sync two things...dah!
-
-;; --------------------------------------------------------------------
-;; Extempore - An Overview
-;; https://vimeo.com/21956071
-;; at 11:30
-;; --------------------------------------------------------------------
-#|
-(define loop
-    (lambda (beat dur root)
-      (for-each (lambda (p offset)
-                  (play (+ offset) sampler p 100 (* 2.0 dur)))
-                (pc:make-chord 40 (cosr 75 10 1/32) 5
-                               (pc:chord root (if (member root '(10 8))
-                                                  '^7
-                                                  '-7)))
-                '(1/3 1 3/2 1 2 3))
-      (callback (*metro* (+ beat (* .5 dur))) 'loop (+ dur beat)
-                dur
-                (if (member root '(0 8))
-                    (random '(2 7 10))
-                    (random '(0 8))))))
-(loop (*metro* get-beat 4) 4 0)
-|#
-
-(fluidsynth:set-reverb *synth* 0.7d0 0.3d0 0.5d0 0.9d0)
-
-(defvar *beat-offset* nil)
-(setf *beat-offset* '(1/3 1 3/2 1 2 3))
-(setf *beat-offset* '(1/3 4 1 1.5))
-(setf (bpm *tempo*) 30)
-
-(progn
-  (setf (fluidsynth:setting *fluid-settings* "synth.gain") .2)
-  (setf (bpm *tempo*) 90)
-)
-  
-(sometune 4 0)
-(flush-pending)
-
-(defun sometune (dur root)
-  (let ((time (now)))
-;    (aat (+ time #[3 b]) #'play-midi-note it 36 90 (* 3.0 dur) 1)
-    (mapcar (lambda (x y)
-            (aat (+ time #[y b]) #'play-midi-note it x 100 (* 2.0 dur) 0))
-            (make-chord 40
-                        (cosr 75 10 1/32)
-                        5
-                        (chord root (if (member root '(10 8))
-                                        '^7
-                                        '-7)))
-            *beat-offset*)
-    (at (+ time #[4 b]) #'sometune
-        dur
-        (if (member root '(0 8))
-            (random-list '(2 7 10))
-            (random-list '(0 8))))))
-
-(setf *beat-offset* (reverse *beat-offset*))
-
-(setf *beat-offset* '(0 0.1 1/3 0.7 0.9 0.9))
-(setf *beat-offset* '(0 0.2 1/3 0.5 0.8))
-(setf *beat-offset* '(0 0.2 0.4 0.6 0.8))
-(setf *beat-offset* '(0 0.1 0.2 0.3 0.4))
-(setf *beat-offset* '(0 0.1 0.11 0.13 0.15 0.17 0.2 0.4 0.5 0.55 0.6 0.8))
-
-;; ----------------------------
-;; Euclidean Rythms
-;; https://github.com/overtone/overtone/blob/master/src/overtone/examples/compositions/euclidean_rhythms.clj
-;; ----------------------------
-
-(setf (bpm *tempo*) 60)
-
-(defun eu (time vel chan beat rythm notes)
-  ;; If rythm is 1 we play the note
-  (if (= 1 (first rythm))
-      (let ((note (first notes)))
-        (play-midi-note time (cm:keynum note) vel 1 chan)
-        (setf notes (alexandria:rotate notes 1))))
-  (aat (tempo-sync #[beat b]) #'eu
-       it
-       vel
-       chan
-       beat
-       (alexandria:rotate rythm 1)
-       notes)
-)
-
-(flush-pending)
-
-(eu (now) 60 0 1/2 (bjorklund 5 13) '(:c3 :g3 :d3))
-(eu (now) 50 1 1   (bjorklund 4 4)  '(:c3 :g3 :d3))
-(eu (now) 50 2 1/2 (bjorklund 3 8)  '(:c3 :g3 :d3))
-
-;; -----------
-;; Playground
-;; https://digego.github.io/extempore/note-level-music.html
-;; http://impromptu.moso.com.au/tutorials/making_music/
-;; -----------
-(setf (fluidsynth:setting *fluid-settings* "synth.gain") .4)
-
-;; arpeggio
-(mapcar (lambda (note delay vel c)
-            (play-midi-note (+ (now) #[delay b]) note vel 2 c)
-            )
-          '(60 64 67 70)
-          '(1 2 3 4)
-          '(90 50 50 60)
-          '(0 1 2 3)
-          )
-;; chord
-(let ((time (now)))
-  (mapcar (lambda (note c)
-            (play-midi-note time note 80 5 c)
-            )
-          '(60 64 67)
-          '(0 1 2)
-          ))
-
-;; 1/f
-(defun 1f (repeats)
-    (mapcar (lambda (note delay vel c)
-            (play-midi-note (+ (now) #[delay b]) note vel 2 c)
-            )
-          (mapcar (lambda (x) (+ 60 x)) (1-over-f repeats))
-          (range (round (/ repeats 2)) :min 1 :step .5)
-          (repeat repeats '(60))
-          (repeat repeats '(0))
-          ))
-
-(1f 30)
-
-;; --------------------------------------------------------------------
-;; GOTO 2014 â€¢ Programming In Time - Live Coding for Creative Performances
-;; https://www.youtube.com/watch?v=Sg2BjFQnr9s
-;; --------------------------------------------------------------------
-#|
-(defun seq-test (&optional (root 60))
-  (let* ((newroot (random-list (cdr (assoc root '((60 58 55)
-                                                  (58 60 56)
-                                                  (56 55 58)
-                                                  (55 60 56)))))))
-    (dsp-seq
-     (play-lsample (+ root -12)  .35 .3)
-     (play-lsample (+ -5  root)  .35 .3)
-           ;(play-lsample  (- root 12) 1 .2 :id 2)
-           ;(play-lsample  (+ 12 root) 1  .2 :id 3)
-           (seq-test newroot))))
-|#
-
-(setf (bpm *tempo*) 60)
-(defvar *root* nil)
-(setf *root* 60)
-(defvar *myscale* nil)
-(setf *myscale* (scale 0 'aeolian))
-
-(defun left (time)
-  (setf *root* (random-list (cdr (assoc *root* '((60 58 55)
-                                                 (58 60 56)
-                                                 (56 55 58)
-                                                 (55 60 56))))))
-     (play-midi-note time (- *root* 12) 60 3 0)
-     (aat (tempo-sync #[3/2 b]) #'play-midi-note it (+ -5  *root*) 60 1 1)
-     (aat (tempo-sync #[4 b])   #'left it))
-
-(defun right ()
-  (play-lsa (round (qcosr *myscale* *root* 7 3/2)) 1.4 .1)
-  (at (tempo-sync #[.5 b]) #'right)
-)
-(left (now))
-(right)
-(flush-pending)
-
-;; --------------------------------------------------------------------
-;; The rules for the algorithm are as follows :
-;;
-;;     two different note lengths need to be defined, e.g. "4" and "3"
-;;     a scale needs to be defined, e.g. C major (the white keys on a piano), let's say we start on the E note, the list of notes will then contain : E, F, G, A, B, C
-;;     a pattern length needs to be defined, e.g. 4 bars
-;;
-;; The algorithm will then function like so (keeping the above definitions in mind) :
-;;
-;;     the first note of the scale (E) is played at the length of the first defined note length (4)
-;;     each time the duration of the played note has ended, the NEXT note in the scale (F) is played
-;;     once the first pattern length has been reached (4 bars), a new pattern will start
-;;     the previously "recorded" pattern will loop its contents indefinitely while the new patterns are created / played
-;;     if a newly played note sounds simultaneously with another note from a PREVIOUS pattern, the note length will change (in above example from 4 to 3).
-;;     this will be the new note length to use for ALL SUBSEQUENT added notes, until another simultaneously played note is found, leading it to switch back to the previous note length (in above example, back to 4).
-;;     as the pattern is now played over an existing one, it is likely that notes will be played in unison, leading to the switching of note length
-;;     as more patterns are accumulated, a perfectly mathematical pattern of notes are weaving in and out of the notes of the other patterns
-;;
-;; https://github.com/igorski/molecular-music-generator
-;; --------------------------------------------------------------------
-
-(defvar *mtempos* nil)
-(setf *mtempos* nil)
-(setf (bpm *tempo*) 50)
-
-;; All piano
-(dotimes (i 32) (fluidsynth:program-change *synth* i 1) )
-
-(fluidsynth:program-change *synth* 2 0)
-(fluidsynth:program-change *synth* 3 0)
-(fluidsynth:program-change *synth* 8 4)
-(fluidsynth:program-change *synth* 7 1)
-(fluidsynth:program-change *synth* 6 1)
-(dotimes (i 32) (fluidsynth:program-change *synth* i ) )
-
-(fluidsynth:set-reverb *synth* 0.2d0 0.0d0 0.5d0 0.9d0)
-(fluidsynth:set-reverb *synth* 0.4d0 0.2d0 0.5d0 0.8d0)
-(fluidsynth:set-reverb *synth* 0.6d0 0.4d0 0.5d0 0.7d0)
-(fluidsynth:set-reverb *synth* 0.8d0 0.7d0 0.5d0 0.6d0)
-(fluidsynth:set-reverb *synth* 0.8d0 1.0d0 0.5d0 0.5d0)
-
-(fluidsynth:set-chorus *synth* 3 10.0d0 0.3d0 8.0d0 0)
-(fluidsynth:set-chorus *synth* 3 4.1d0 0.3d0 1.0d0 1)
-
-(setf (fluidsynth:setting *fluid-settings* "synth.gain") 1.4)
+(defun all-piano(s)
+(setf (fluidsynth:setting *fluid-settings* "synth.gain") .6)
 ;; (define-constant CHORUS-DEFAULT-N      3)  
 ;; (define-constant CHORUS-DEFAULT-LEVEL  2.0d0)
 ;; (define-constant CHORUS-DEFAULT-SPEED  0.3d0)
@@ -605,10 +176,12 @@
 ;; 15 wind
 
 (fluidsynth:program-change *synth* 0 32)
-(fluidsynth:program-change *synth* 1 12)
-(fluidsynth:program-change *synth* 2 10)
 (fluidsynth:program-change *synth* 1 10)
+(fluidsynth:program-change *synth* 2 10)
 
+(fluidsynth:program-change *synth* 0 22)
+(fluidsynth:program-change *synth* 1 77)
+(fluidsynth:program-change *synth* 2 33)
 
 (cage -12 30 0)
 (cage 0 50 1)
@@ -690,6 +263,16 @@ h half   x sixty-fourth
 (fluidsynth:program-change *synth* 2 43)
 (fluidsynth:program-change *synth* 1 46)
 
+
+(fluidsynth:program-change *synth* 4 1)
+
+(fluidsynth:program-change *synth* 3 33)
+
+
+
+(fluidsynth:program-change *synth* 1 46)
+(fluidsynth:program-change *synth* 1 46)
+
 (defun pp (chan time keys rhythms)
   (let ((note   (cm:keynum (cm:next keys)))
         (rhythm (cm:rhythm (cm:next rhythms) 30)))
@@ -758,10 +341,10 @@ h half   x sixty-fourth
 ;; 37- winds wood
 ;; 40- winds brass
 ;; 46- winds synth
-(fluidsynth:program-change *synth* 1 1)
+(fluidsynth:program-change *synth* 1 40)
 (fluidsynth:program-change *synth* 2 1)
 (fluidsynth:program-change *synth* 3 1)
-(fluidsynth:program-change *synth* 4 1)
+(fluidsynth:program-change *synth* 1 1)
 (fluidsynth:program-change *synth* 3 33)
 (fluidsynth:program-change *synth* 4 40)
 
@@ -769,7 +352,7 @@ h half   x sixty-fourth
     (tempo-sync #[1 b])
     (cm:new cm:cycle :of '(e3 gs4 b4 ds4)))
 
-(p 4 40 (tempo-sync #[1 b])
+(p 4 30 (tempo-sync #[1 b])
    (cm:new cm:cycle :of '(e3 gs4 b4 ds4))
    (cm:new cm:cycle :of '(s e s. e. q))
    (cm:new cm:cycle :of '(1)))
@@ -784,7 +367,7 @@ h half   x sixty-fourth
   (q3 4 35 (tempo-sync #[1 b])
       (cm:new cm:heap :of '(e4 fs5)) :life 10)
   (q4 4 45 (tempo-sync #[1 b])
-      (cm:new cm:heap :of '(fs3)) :life 10))
+      (cm:new cm:heap :of '(fs3)) :life 10) )
 
 
 (defun q5 (rhythms)
@@ -857,6 +440,14 @@ h half   x sixty-fourth
 
 (m (tempo-sync #[1 b])
    (cm:markov-analyze chorale1 :order 1 :print? nil))
+
+(defun m (time chords)
+  (let ((chord (cm:next chords)))
+    (play-midi-note time (cm:keynum (nth 0 chord)) 30 1 1)
+    (play-midi-note (+ time #[1 b]) (cm:keynum (nth 1 chord)) 30 1 1)
+    (play-midi-note (+ time #[2 b]) (cm:keynum (nth 2 chord)) 30 1 1)
+    (aat (+ time #[3 b]) #'m it chords)))
+
 ;; --------------------------------
 (defvar idxdur '((0.018 q) (.697 q)  (1.376 s)
                  (1.538 e) (1.869 s) (2.032 s)
@@ -896,6 +487,13 @@ h half   x sixty-fourth
 ;; Fractal music
 ;; https://github.com/holgafreak/maxann-grace
 ;; https://web.archive.org/web/20000118053335/http://www.sci.fi/~mjkoskin/fractal.cm
+
+;; ----------------------------------
+;; Morse-Thue
+;; From:
+;; - "Music composition with lisp"
+;; - nudruz
+ 
 (defvar mtrules nil)
 
 (setf mtrules '((0 :-> (0 1)) 
@@ -919,3 +517,87 @@ h half   x sixty-fourth
     (1 (rw-next rwrules initgen))
     (t (rw-next rwrules (rwgen rwrules initgen (- gennbr 1))))))
 
+(defun pw (chan time notes amps)
+  (let* ((amp  (cm:next amps)))
+    (if (= amp 1)
+        (play-midi-note time (cm:next notes) 40 1 chan))
+    (aat (tempo-sync #[1 b]) #'pw chan it notes amps)))
+
+; clav  - 19
+; brass - 40
+(fluidsynth:program-change *synth* 1 16)
+(fluidsynth:program-change *synth* 2 41)
+
+(defvar *chord* nil)
+(setf *chord* (make-chord 50 60 3 (scale 0 'aeolian)))
+(defvar *cycle* nil)
+(setf *cycle* (cm:new cm:cycle :of *chord*))
+
+(pw 1
+    (tempo-sync #[1 b])
+    (cm:new cm:cycle :of *chord*)
+    (cm:new cm:cycle :of (rwgen mtrules '(1 0) 2)))
+ 
+(pw 2
+    (tempo-sync #[1 b])
+    (cm:new cm:cycle :of *chord*)
+    (cm:new cm:cycle :of (rwgen mtrules '(1 0) 4))))
+
+#|
+(flush-pending)
+(off-with-the-notes *synth*)
+|#
+
+;; This one has "dynamic" chord progression
+
+(setf (bpm *tempo*) 60)
+
+(defvar *chord* nil)
+(defvar *notes* nil)
+(setf *chord* (make-chord 50 65 5 (scale 0 'phrygian)))
+(setf *notes*  (cm:new cm:cycle :of *chord*))
+
+(defun pw (chan time amps)
+  (let* ((amp  (cm:next amps)))
+    (if (= amp 1)
+        (play-midi-note time (cm:next *notes*) 40 1 chan))
+    (aat (tempo-sync #[1 b]) #'pw chan it amps)))
+
+(pw 1
+    (tempo-sync #[1 b])
+    (cm:new cm:cycle :of (rwgen mtrules '(1 0) 2)))
+
+(pw 2
+    (tempo-sync #[1 b])
+    (cm:new cm:cycle :of (rwgen mtrules '(1 0) 4))))
+
+
+;; EXPWARP -- 'warps' pits by expt factor
+;; (above optional bass-note, or lowest note in chd)
+(defun expwarp (pits factor &optional (bassnote nil))
+      (let* ((orig-hz (remove-duplicates (cm:hertz pits)))
+	     (bn (if bassnote bassnote (apply #'min orig-hz)))
+	     (hzdiffs (mapcar (lambda (x) (- x bn)) orig-hz)))
+	(loop for n to (- (length orig-hz) 1) collect
+	      (cm:keynum
+	       (+ bn (* (nth n hzdiffs) factor))
+	       :hz 't))))
+
+(fluidsynth:program-change *synth* 1 1)
+
+(defvar *chords* nil)
+(setf *chords*  (cm:new cm:cycle :of (loop :for n :from 1.0 :to 2.0 :by .1 :collect (expwarp '(36 55 64) n))))
+
+(defun ew (time)
+  (let ((chord (cm:next *chords*)))
+    (dolist (k chord)
+      (play-midi-note time (round k) 30 1 1))
+    (aat (+ (now) #[1 b]) #'ew it)))
+
+(ew (now))
+
+(defun ewinc (time)
+  (setf *chords* (cm:new cm:cycle :of (loop :for n :from 1.0 :to 2.0 :by (random-list '(.2 .3 .4)) :collect (expwarp '(36 55 64) n))))
+  (aat (+ time #[4 b]) #'ewinc it))
+
+(ewinc .1)
